---
title: Create a sphere with points in Threejs
slug: create-a-sphere-with-points-in-threejs
date: 2025-02-20T08:00:00.000Z
---

Recently, I watching Akela's stream about create a sphere with points in Threejs. So I decided to write a post about it.
The url of the stream is [here](https://www.youtube.com/watch?v=u1mRIYd7L44).

<Callout variant="info">
The golden ratio is a special number approximately equal to 1.6180. We can use this formular to create golden ratio:
</Callout>

There are several ways to place points evenly in the sphere. I will use the golden ratio method. Golden ratio is a special number approximately equal to 1.6180. We can use this formular to create golden ratio:

<PointSphereSandpack scene="scene1" />

Now for the code: 

```js 
const goldenRatio = (1 + Math.sqrt(5)) / 2;
```

Let's create a sphere with dots in Threejs. First, we need to create a sphere:

Then, we need to place dots in the sphere. We can use the golden ratio method to place dots evenly in the sphere:

```ts
// [!code highlight:3]
import { Base } from "./base.ts";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/Addons.js";

class App extends Base {
  constructor() {
    super();

    const pointsNumber = 5000;
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    const positions: number[][] = [];
    
    for (let i = 0; i < pointsNumber; i++) {
      const prog = i / pointsNumber;
      const theta = (2 * Math.PI * i) / goldenRatio;
      const phi = Math.acos(1 - 2 * prog);
      const x = Math.cos(theta) * Math.sin(phi);
      const z = Math.sin(theta) * Math.sin(phi);
      const y = Math.cos(phi);
      
      positions.push([x, y, z]);
    }
        
    const dotMat = new THREE.ShaderMaterial();
    
    const dotGeo = new THREE.PlaneGeometry(0.01, 0.01);

    const dots = new THREE.InstancedMesh(dotGeo, dotMat, pointsNumber);
    const dummy = new THREE.Object3D();

    for (let i = 0; i < positions.length; i++) {
      const pos = new THREE.Vector3(
      	positions[i][0],
      	positions[i][1],
      	positions[i][2],
      );
      
      dummy.position.copy(pos);
      dummy.lookAt(pos.multiplyScalar(2));
      dummy.updateMatrix();
      dots.setMatrixAt(i, dummy.matrix);
    }

    dots.instanceMatrix.needsUpdate = true;
    this.scene.add(dots);
  }

  public animate() {
    this.renderer.render( this.scene, this.camera );
  }
}

new App();
```

Vertex shader:

```glsl
vec3 pointLight(vec3 lightColor, float lightIntensity, vec3 normal, vec3 lightPosition, vec3 viewDirection, float specularPower, vec3 position, float lightDecay) {
    vec3 lightDelta = lightPosition - position;
    float lightDistance = length(lightDelta);
    vec3 lightDirection = normalize(lightDelta);
    vec3 lightReflection = reflect(-lightDirection, normal);

    // Shading
    float shading = dot(normal, lightDirection);
    shading = max(0.0, shading);

    // Specular
    float specular = -dot(lightReflection, viewDirection);
    specular = max(0.0, specular);
    specular = pow(specular, specularPower);

    // Decay
    float decay = 1.0 - lightDistance * lightDecay;
    decay = max(0.0, decay);

    return lightColor * lightIntensity * decay * (shading + specular);
}

#pragma glslify: export(pointLight)
```

Explanation of the code:

- `dotsNumber`: number of dots in the sphere. Default is 30000.
- progress: progress of the loop, from 0 to 1.
- theta: angle of the dot in the sphere in the xz plane.
- phi: angle of the dot in the sphere in the yz plane.



Something here

```tsx
import React, { useEffect, useRef } from 'react';

export default function Test(){
    return (
        <div>
            <canvas id="canvas"></canvas>
        </div>
    )
}
```

